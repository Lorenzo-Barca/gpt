In file included from /temp_local/bal43566/gpt/dependencies/Grid/Grid/lattice/Lattice.h:32,
                 from /temp_local/bal43566/gpt/dependencies/Grid/Grid/GridCore.h:58,
                 from /temp_local/bal43566/gpt/dependencies/Grid/Grid/Grid.h:41,
                 from lib/instantiate/../lib.h:30,
                 from lib/instantiate/expression_linear_combination_single_iVColor3.cc:20:
/temp_local/bal43566/gpt/dependencies/Grid/Grid/lattice/Lattice_ET.h: In instantiation of ‘decltype (Grid::LatticeBinaryExpression<Grid::BinaryMul<decltype (Grid::eval(0, lhs)), decltype (Grid::eval(0, rhs))>, T1, T2>(Grid::BinaryMul<decltype (Grid::eval(0, lhs)), decltype (Grid::eval(0, rhs))>(), lhs, rhs)) Grid::operator*(const T1&, const T2&) [with T1 = std::complex<float>; T2 = Grid::Lattice<Grid::iScalar<Grid::iScalar<Grid::iVector<Grid::Grid_simd<std::complex<float>, __vector(8) float>, 3> > > >; typename std::enable_if<((! std::is_base_of<Grid::LatticeBase, T>::value) && (! std::is_base_of<Grid::LatticeExpressionBase, T>::value)), T1>::type* <anonymous> = 0; typename std::enable_if<(std::is_base_of<Grid::LatticeBase, _T1>::value || std::is_base_of<Grid::LatticeExpressionBase, T2>::value), T2>::type* <anonymous> = 0; decltype (Grid::LatticeBinaryExpression<Grid::BinaryMul<decltype (Grid::eval(0, lhs)), decltype (Grid::eval(0, rhs))>, T1, T2>(Grid::BinaryMul<decltype (Grid::eval(0, lhs)), decltype (Grid::eval(0, rhs))>(), lhs, rhs)) = Grid::LatticeBinaryExpression<Grid::BinaryMul<std::complex<float>, const Grid::iScalar<Grid::iScalar<Grid::iVector<Grid::Grid_simd<std::complex<float>, __vector(8) float>, 3> > >&>, std::complex<float>, Grid::Lattice<Grid::iScalar<Grid::iScalar<Grid::iVector<Grid::Grid_simd<std::complex<float>, __vector(8) float>, 3> > > > >; decltype (Grid::eval(0, rhs)) = const Grid::iScalar<Grid::iScalar<Grid::iVector<Grid::Grid_simd<std::complex<float>, __vector(8) float>, 3> > >&; decltype (Grid::eval(0, lhs)) = std::complex<float>]’:
lib/instantiate/../expression/linear_combination.h:53:5:   required from ‘cgpt_Lattice_base* cgpt_compatible_linear_combination(Grid::Lattice<vobj>&, cgpt_Lattice_base*, bool, std::vector<cgpt_lattice_term>&, int, int) [with T = Grid::iScalar<Grid::iScalar<Grid::iVector<Grid::Grid_simd<std::complex<float>, __vector(8) float>, 3> > >]’
lib/instantiate/expression_linear_combination_single_iVColor3.cc:30:1:   required from here
/temp_local/bal43566/gpt/dependencies/Grid/Grid/lattice/Lattice_ET.h:424:16: note: the ABI of passing structure with complex float member has changed in GCC 4.4
 GRID_DEF_BINOP(operator*, BinaryMul);
                ^~~~~~~~
/temp_local/bal43566/gpt/dependencies/Grid/Grid/lattice/Lattice_ET.h:375:15: note: in definition of macro ‘GRID_BINOP_RIGHT’
   inline auto op(const T1 &lhs, const T2 &rhs)    \
               ^~
/temp_local/bal43566/gpt/dependencies/Grid/Grid/lattice/Lattice_ET.h:424:1: note: in expansion of macro ‘GRID_DEF_BINOP’
 GRID_DEF_BINOP(operator*, BinaryMul);
 ^~~~~~~~~~~~~~
